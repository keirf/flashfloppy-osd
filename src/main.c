/*
 * main.c
 * 
 * Bootstrap the STM32F103C8T6 and get things moving.
 * 
 * Written & released by Keir Fraser <keir.xen@gmail.com>
 * 
 * This is free and unencumbered software released into the public domain.
 * See the file COPYING for more details, or visit <http://unlicense.org>.
 */

/*
 * PIN ASSIGNMENTS:
 * 
 * FF OSD I2C Special Protocol (use with FlashFloppy v3.4a or later):
 *  A0-A1: Jumper/Strap
 * 
 * Reset to Factory Defaults:
 *  A1-A2: Jumper/Strap
 *
 * Rotary Encoder:
 *  A0: CLK
 *  A1: DAT
 *  A2: SEL
 * [NB. Rotary Encoder is unavailable if A0-A1 is jumpered, but FF OSD
 *      can be configured via FlashFloppy]
 * 
 * Serial Console:
 *  A9: TX
 *  A10: RX
 * 
 * I2C Interface (to Gotek):
 *  B6: CLK
 *  B7: DAT
 * 
 * I2C2 Interface (to slave OSD):
 *  B10: CLK2
 *  B11: DAT2
 * 
 * Display:
 *  A7: Display output SPI1
 *  A8: CSYNC or HSYNC
 *  B14: VSYNC (only needed with HSYNC)
 *  B15: Display output SPI2
 *  A15: Display enable
 * 
 * Amiga keyboard:
 *  B3: KBDAT
 *  B4: KBCLK
 * 
 * Amiga signals:
 *  A12: CTS
 * 
 * User outputs:
 *  B8:  U0
 *  B9:  U1
 *  B12: U2
 */

/* CSYNC/HSYNC (A8): EXTI IRQ trigger and TIM1 Ch.1 trigger. */
#define gpio_csync gpioa
#define pin_csync  8
#define irq_csync  23
void IRQ_23(void) __attribute__((alias("IRQ_csync"))); /* EXTI9_5 */

/* VSYNC (B14): EXTI IRQ trigger. */
#define gpio_vsync gpiob
#define pin_vsync  14
#define irq_vsync  40
void IRQ_40(void) __attribute__((alias("IRQ_vsync"))); /* EXTI15_10 */

/* TIM1 Ch.3: Triggered at horizontal end of OSD box. 
 * TIM1 counter is started by TIM2 UEV (ie. when SPI DMA begins). */
#define tim1_ch3_dma (dma1->ch6)
#define tim1_ch3_dma_ch 6
#define tim1_ch3_dma_tc_irq 16
void IRQ_16(void) __attribute__((alias("IRQ_osd_end")));

/* TIM1 Ch.4: Triggered 1us before TIM1 Ch.3. Generates IRQ. */
#define tim1_cc_irq 27
void IRQ_27(void) __attribute__((alias("IRQ_osd_pre_end")));

/* TIM2: Ch.1 Output Compare triggers IRQ. Overflow triggers SPI DMA. 
 * Counter starts on TIM1 UEV (itself triggered by TIM1 Ch.1 input pin). */
#define tim2_irq 28
void IRQ_28(void) __attribute__((alias("IRQ_osd_pre_start")));
#define tim2_up_dma (dma1->ch2)
#define tim2_up_dma_ch 2
#define tim2_up_dma_tc_irq 12

/* TIM4: Overflow triggers DMA to enable Display Output.
 * Counter starts on TIM1 UEV (itself triggered by TIM1 Ch.1 input pin). */
#define tim4_irq 30
#define tim4_up_dma (dma1->ch7)
#define tim4_up_dma_ch 7
#define tim4_up_dma_tc_irq 17

/* Display Output (A7): Pixels are generated by SPI1. */
#define gpio_display_spi1 gpioa
#define pin_display_spi1_mosi 7
#define pin_display_spi1_sck  5
#define spi_display_spi1  (spi1)
#define dma_display_spi1  (dma1->ch3)
#define dma_display_ch_spi1 3
#define dma_display_irq_spi1 13

/* Display Output (B15): Pixels are generated by SPI2. */
#define gpio_display_spi2 gpiob
#define pin_display_spi2_mosi 15
#define pin_display_spi2_sck  13
#define spi_display_spi2  (spi2)
#define dma_display_spi2  (dma1->ch5)
#define dma_display_ch_spi2 5
#define dma_display_irq_spi2 15

/* Display Enable (A15): If using an external tristate buffer. */
#define gpio_dispen gpioa
#define pin_dispen  15

/* List of interrupts used by the display-sync and -output system. */
const static uint8_t irqs[] = {
    tim1_cc_irq, tim2_irq, tim1_ch3_dma_tc_irq, irq_csync, irq_vsync
};

int EXC_reset(void) __attribute__((alias("main")));

#include "font.h"

void setup_spi(uint16_t video_mode);
static void slave_arr_update(void);
static uint16_t startup_display_spi;
static uint16_t startup_dispctl_mode;
uint16_t running_display_timing;
uint16_t running_polarity, detected_polarity;

/* Guard the stacks with known values. */
static void canary_init(void)
{
    _irq_stackbottom[0] = _thread_stackbottom[0] = 0xdeadbeef;
}

/* Has either stack been clobbered? */
static void canary_check(void)
{
    ASSERT(_irq_stackbottom[0] == 0xdeadbeef);
    ASSERT(_thread_stackbottom[0] == 0xdeadbeef);
}

static void watchdog_init(void)
{
    /* Set up the Watchdog. Based on LSI at 30-60kHz (av. 40kHz). */
    iwdg->kr = 0xcccc; /* Enables watchdog, turns on LSI oscillator. */
    while (iwdg->sr & 3) {
        /* System Memory Bootloader modifies PR. We must wait for that 
         * to take effect before making our own changes. */
    }
    iwdg->kr = 0x5555; /* Enables access to PR and RLR. */
    iwdg->pr = 3;      /* Prescaler: div32 => Ticks at 937-1875Hz (1250Hz) */
    iwdg->rlr = 400;   /* Reload:    400   => Times out in 213-426ms (320ms) */
    iwdg->kr = 0xaaaa; /* Load the new Reload value. */
}

static void watchdog_kick(void)
{
    /* Reload the Watchdog. */
    iwdg->kr = 0xaaaa;
}

static struct timer button_timer;
static uint8_t rotary;
static volatile uint8_t buttons;
volatile unsigned int vstart;

/* Amiga keyboard for quick change display settings */
static void button_amikeys(void)
{
    if (amiga_key_pressed(AMI_W))
        config.v_off = max_t(uint16_t, config.v_off-1, 2);
    if (amiga_key_pressed(AMI_S))
        config.v_off = min_t(uint16_t, config.v_off+1, 299);
    if (amiga_key_pressed(AMI_A))
        config.h_off = max_t(uint16_t, config.h_off-1, 1);
    if (amiga_key_pressed(AMI_D))
        config.h_off = min_t(uint16_t, config.h_off+1, 199);

#ifndef NDEBUG
    /* Sync Polarity. */
    if (amiga_key_pressed(AMI_KPPLUS)) {
        running_polarity = config.polarity = SYNC_HIGH;
    }
    if (amiga_key_pressed(AMI_KPMINUS)) {
        running_polarity = config.polarity = SYNC_LOW;
    }
    if (amiga_key_pressed(AMI_KPLEFTPAREN)) {
        config.display_timing = DISP_15KHZ;
        setup_spi(config.display_timing);
    }
    if (amiga_key_pressed(AMI_KPRIGHTPAREN)) {
        config.display_timing = DISP_VGA;
        setup_spi(config.display_timing);
    }
    if (amiga_key_pressed(AMI_KPSLASH)) {
        config.display_timing = DISP_AUTO;
        config.polarity = SYNC_AUTO;
    }
#endif
}

static uint8_t get_buttons(void)
{
    /* Rotary encoder outputs a Gray code, counting clockwise: 00-01-11-10. */
    enum { ROT_none, ROT_full, ROT_half, ROT_quarter } rotary_type = ROT_full;
    const uint32_t rotary_transitions[] = {
        [ROT_none]    = 0x00000000, /* No encoder */
        [ROT_full]    = 0x20000100, /* 4 transitions (full cycle) per detent */
        [ROT_half]    = 0x24000018, /* 2 transitions (half cycle) per detent */
        [ROT_quarter] = 0x24428118  /* 1 transition (quarter cyc) per detent */
    };

    static uint16_t _b;
    uint8_t b = 0;

    /* We debounce the switch by waiting for it to be pressed continuously 
     * for 16 consecutive sample periods (16 * 5ms == 80ms) */
    _b <<= 1;
    _b |= gpio_read_pin(gpioa, 2);
    if (_b == 0)
        b |= B_SELECT;

    rotary = ((rotary << 2) | (gpioa->idr & 3)) & 15;
    b |= (rotary_transitions[rotary_type] >> (rotary << 1)) & 3;

    return b;
}

static int count_100ms;
static void button_timer_fn(void *unused)
{
    uint8_t b = B_PROCESSED;

    /* Rotary Encoder is not supported with FF OSD custom I2C protocol. */
    if (!i2c_osd_protocol)
        b |= get_buttons();

    /* Latch final button state and reset the timer. */
    buttons |= b;
    timer_set(&button_timer, button_timer.deadline + time_ms(5));

    if (++count_100ms > 20) {
        count_100ms = 0;
        button_amikeys();
    }
}

#define MAX_DISPLAY_HEIGHT 52
static uint16_t display_dat[MAX_DISPLAY_HEIGHT][40/2+1];
static struct display *cur_display = &i2c_display;
struct display no_display;
static uint16_t display_height;


static void slave_arr_update(void)
{
    unsigned int hstart;
    switch (running_display_timing) {
        case DISP_VGA:
            vstart = config.v_off*2;
            if (startup_display_spi == DISP_SPI1) {
                hstart = config.h_off * 7;
                /* Enable output pin first (TIM4) and then start SPI transfers
                 * (TIM2). Timers run at 72 MHz, pixel clock is 36 MHz, 2 ticks
                 * per pixel: (13-1)/2 = 6 pixel */
                tim4->arr = hstart-12;
                tim2->arr = hstart-1;
            } else {
                hstart = config.h_off * 7;
                /* Enable output pin first (TIM4) and then start SPI transfers
                 * (TIM2). Timers run at 72 MHz, pixel clock is 18 MHz, 4 ticks
                 * per pixel: (25-1)/4 = 6 pixel */
                tim4->arr = hstart-24;
                tim2->arr = hstart-1;
            }
        break;

        case DISP_15KHZ:
        default:
            vstart = config.v_off;
            hstart = config.h_off * 20;
            /* Enable output pin first (TIM4) and then start SPI transfers
             * (TIM2). Timers run at 72 MHz, pixel clock is 9 MHz, 8 ticks per
             * pixel: (49-1)/8 = 6 pixel */
            tim4->arr = hstart-49;
            tim2->arr = hstart-1;
        break;
    }

    /* Trigger TIM2 IRQ 1us before OSD box. */
    tim2->ccr1 = hstart - sysclk_us(1);
}

static void set_polarity(void)
{
    if (running_polarity) {
        /* Active High: Rising edge = sync start */
        exti->ftsr &= ~(m(pin_csync) | m(pin_vsync));
        exti->rtsr |= m(pin_csync) | m(pin_vsync); /* Rising edge */
        tim1->ccer |= TIM_CCER_CC1P; /* Falling edge */
    } else {
        /* Active Low: Falling edge = sync start */
        exti->rtsr &= ~(m(pin_csync) | m(pin_vsync));
        exti->ftsr |= m(pin_csync) | m(pin_vsync); /* Falling edge */
        tim1->ccer &= ~TIM_CCER_CC1P; /* Rising edge */
    }
}

static int hline, frame;
#define HLINE_EOF -1
#define HLINE_VBL 0
#define HLINE_SOF 1

static void IRQ_vsync(void)
{
    exti->pr = m(pin_vsync);
    tim1->smcr = 0;
    hline = HLINE_VBL;
}

#define sync_log_MAX 20
volatile static int sync_log_ptr;
volatile static int32_t sync_log[sync_log_MAX];

#define sync_sum_MAX 1000
volatile static int sync_sum_ptr;
volatile static int32_t sync_sum_high;
volatile static int32_t sync_sum_low;

static time_t last_sync_time;

static void IRQ_csync(void)
{
    exti->pr = m(pin_csync);

    if (hline <= 0) { /* EOF or VBL */

        static time_t p, last_polarity_time;
        time_t t = time_now();
        bool_t csync_now = gpio_read_pin(gpio_csync, pin_csync);

        /* Trigger on both sync edges so we can measure sync pulse width: 
         * Normal Sync ~= 5us, Porch+Data ~= 59us */
        exti->ftsr |= m(pin_csync) | m(pin_vsync);
        exti->rtsr |= m(pin_csync) | m(pin_vsync);

        /* do some sync polarity calculations */
        /* ignore negative diff */
        if ( time_diff(last_polarity_time, t) < 0 )
            last_polarity_time = t;

        if (csync_now) // its high now, so it was a low pulse
            sync_sum_low += time_diff(last_polarity_time, t);
        else
            sync_sum_high += time_diff(last_polarity_time, t);
        last_polarity_time = t;

        if (sync_sum_ptr++ >= sync_sum_MAX) {

            /* 39kHz VGA is  low for ~11x longer than high
             * 15kHz PAL is high for ~13x longer than low */
            if (sync_sum_low > 8*sync_sum_high)
                detected_polarity = SYNC_HIGH;
            if (sync_sum_high > 4*sync_sum_low)
                detected_polarity = SYNC_LOW;

            sync_sum_low = sync_sum_high = sync_sum_ptr = 0;
        }

        if (csync_now == running_polarity) {

            /* Sync pulse start: remember the current time. */
            p = t;

        } else if (time_diff(p, t) > time_us(10)) {

            /* Long sync: We are in vblank. */
            hline = HLINE_VBL;

        } else if (hline == HLINE_VBL) {

            /* Short sync: We are outside the vblank period. Start frame (we
             * were previously in vblank). */
            hline = HLINE_SOF;
            slave_arr_update();
            set_polarity();

        }

    } else if (++hline < vstart) {

        /* Before vertical start of OSD: Time hsync pulses. */
        time_t this_sync_time = time_now();
        sync_log[sync_log_ptr++] =  time_diff(last_sync_time, this_sync_time);
        last_sync_time = this_sync_time;
        if (sync_log_ptr >= sync_log_MAX)
            sync_log_ptr = 0;

    } else if (hline >= (vstart + display_height)) {

        /* Vertical end of OSD: Disable TIM1 trigger and signal main loop. */
        tim1->smcr = 0;
        hline = HLINE_EOF;
        frame++;

    } else {

        /* Within OSD vertical area: Set up for next line. */

        /* Set TIM1 to reset (causing UEV) when triggered by Ch.1 input pin
         * (Ch.1 input pin is CSYNC/HSYNC, triggering on end-of-sync). */
        tim1->smcr = (TIM_SMCR_MSM
                      | TIM_SMCR_TS(5) /* Filtered TI1 */
                      | TIM_SMCR_SMS(4)); /* Reset Mode */

        if (hline == vstart) {
            /* Set up for first line of OSD box. */
            if (startup_display_spi == DISP_SPI1) {
                dma_display_spi1.cmar = (uint32_t)(unsigned long)display_dat;
            } else {
                dma_display_spi2.cmar = (uint32_t)(unsigned long)display_dat;
            }
        }
    }
}

/* Display On/Off: Which register to write, and what values to write there. */
static uint32_t dispctl_reg;
static uint32_t dispctl_on;
static uint32_t dispctl_off;

/* Called during initialisation to set the display-control variables based on 
 * configured display-control mode. */
static void setup_dispctl_mode(void)
{
    /* AT32F403: SPI master is not clocked unless SCK pin is configured 
     * alternate function output. */
    if (startup_display_spi == DISP_SPI1) {
        gpio_configure_pin(gpio_display_spi1, pin_display_spi1_sck,
                           AFO_pushpull(_50MHz));
        gpio_configure_pin(gpio_display_spi1, pin_display_spi1_mosi,
                           AFO_pushpull(_50MHz));
    } else {
        gpio_configure_pin(gpio_display_spi2, pin_display_spi2_sck,
                           AFO_pushpull(_50MHz));
        gpio_configure_pin(gpio_display_spi2, pin_display_spi2_mosi,
                           AFO_pushpull(_50MHz));
    }

    switch (startup_dispctl_mode) {

    case DISPCTL_tristate:
        /* PA15: Unused 
         * SPIx: Tristate outside OSD box */

        if (startup_display_spi == DISP_SPI1) {
            /* PA7, SPI1 */
            dispctl_reg = (uint32_t)(unsigned long)&gpio_display_spi1->crl;
            dispctl_on = gpio_display_spi1->crl;
            gpio_configure_pin(gpio_display_spi1, pin_display_spi1_mosi,
                               GPI_floating);
            dispctl_off = gpio_display_spi1->crl;

        } else {
            /* PB15, SPI2 */
            dispctl_reg = (uint32_t)(unsigned long)&gpio_display_spi2->crh;
            dispctl_on = gpio_display_spi2->crh;
            gpio_configure_pin(gpio_display_spi2, pin_display_spi2_mosi,
                               GPI_floating);
            dispctl_off = gpio_display_spi2->crh;
        }
        break;

    case DISPCTL_enable_high:
    case DISPCTL_enable_low: {
        /* PA15: Display Enable: Active HIGH or LOW 
         * SPIx: Always driven */
        bool_t active_low = (startup_dispctl_mode == DISPCTL_enable_low);

        gpio_configure_pin(gpio_dispen, pin_dispen,
                           GPO_pushpull(_50MHz, active_low));
        dispctl_reg = (uint32_t)(unsigned long)&gpio_dispen->bsrr;
        dispctl_on = 1u << (pin_dispen + (active_low ? 16 : 0));
        dispctl_off = 1u << (pin_dispen + (active_low ? 0 : 16));
        break;
    }

    }
}

static uint16_t dma_display_ccr = (DMA_CCR_PL_V_HIGH |
                                   DMA_CCR_MSIZE_16BIT |
                                   DMA_CCR_PSIZE_16BIT |
                                   DMA_CCR_MINC |
                                   DMA_CCR_DIR_M2P |
                                   DMA_CCR_EN);

/* Triggered by TIM2 1us before the start of the OSD box. We use this to 
 * quiesce interrupts during the critical initial OSD DMAs. We also retask
 * TIM1 to cleanly finish the OSD box at end of line. */
static void IRQ_osd_pre_start(void)
{
    /* Set TIM1 to start counting when triggered by TIM2. Output-compare 
     * will trigger DMA to disable OSD output at end of line. */
    tim1->smcr = (TIM_SMCR_TS(1) /* Timer 2 */
                  | TIM_SMCR_SMS(6)); /* Trigger Mode (starts counter) */

    tim2->sr = 0;
    delay_us(1);
}

/* Triggered by TIM1's Ch.4 Output Compare. */
static void IRQ_osd_pre_end(void)
{
    tim1->sr = 0;
    delay_us(1);
}

/* Triggered by TIM1's DMA completion at horizontal end of OSD box. */
static void IRQ_osd_end(void)
{
    /* Clear interrupt and stop timer. */
    dma1->ifcr = DMA_IFCR_CGIF(tim1_ch3_dma_ch);
    tim1->cr1 &= ~TIM_CR1_CEN;

    /* Point SPI DMA at next line of data. */
    if (startup_display_spi == DISP_SPI1) {
        dma_display_spi1.ccr = 0;
        dma_display_spi1.cndtr = cur_display->cols/2 + 1;

        /* If we're double height, only update dma display pointer
         * when this is an odd line number of the display area
         * We're doing double rows, vstart has single row resolution
         * check oddness using difference between this line and start */
        if ((config.display_2Y == FALSE) || ((hline - vstart) & 0x1))
            dma_display_spi1.cmar += sizeof(display_dat[0]);

    } else {
        dma_display_spi2.ccr = 0;
        dma_display_spi2.cndtr = cur_display->cols/2 + 1;
        if ((config.display_2Y == FALSE) || ((hline - vstart) & 0x1))
            dma_display_spi2.cmar += sizeof(display_dat[0]);
    }
}

/* Set up a slave timer to be triggered by TIM1. */
static void setup_slave_timer(TIM tim)
{
    tim->psc = 0;
    tim->egr = TIM_EGR_UG; /* update CNT, PSC, ARR */
    tim->cr2 = 0;
    tim->dier = TIM_DIER_UDE;
    tim->cr1 = TIM_CR1_ARPE | TIM_CR1_URS | TIM_CR1_OPM;
    tim->smcr = (TIM_SMCR_TS(0) /* Timer 1 */
                 | TIM_SMCR_SMS(6)); /* Trigger Mode (starts counter) */
}

static void render_line(int y, const struct display *display)
{
    unsigned int x, row;
    const uint8_t *t;
    uint16_t *d = display_dat[y];

    memset(d, 0, sizeof(display_dat[0]));

    /* Top two lines are blank. */
    y -= 2;

    /* Work out which text row we are on. */
    for (row = 0; row < display->rows; row++) {
        int nr = (display->heights & (1u<<row)) ? 16 : 8;
        if (y < 0)
            return;
        if (y < nr)
            break;
        y -= nr + 2; /* Two blank lines between each row of text. */
    }

    /* Done all rows? Final two lines are blank. */
    if (row >= display->rows)
        return;

    /* If this is a double-height row, each pixel line is repeated. */
    if (display->heights & (1u<<row))
        y /= 2;

    t = display->text[row];

    for (x = 0; x < display->cols; x++) {
        uint8_t c = *t++;
        if ((c < 0x20) || (c > 0x7f))
            c = 0x20;
        c -= 0x20;
        d[x/2] |= (uint16_t)font[(c<<3)+y] << ((x&1)?0:8);
    }
}

/* Keypress action notifier. */
struct display notify;
static time_t notify_time;

/* We snapshot the relevant Amiga keys so that we can scan the keymap (and 
 * clear the sticky bits) in one place in the main loop. */
static uint8_t keys;
#define K_LEFT   B_LEFT
#define K_RIGHT  B_RIGHT
#define K_SELECT B_SELECT
#define K_MENU   8

static bool_t osd_on = TRUE;

static void update_amiga_keys(void)
{
    int i, row;
    static bool_t del_pressed;

    /* Check keys-as-buttons. */
    keys = 0;
    if (amiga_key_pressed(AMI_LEFT)) keys |= K_LEFT;
    if (amiga_key_pressed(AMI_RIGHT)) keys |= K_RIGHT;
    if (amiga_key_pressed(AMI_UP)) keys |= K_SELECT;
    if (amiga_key_pressed(AMI_HELP)) keys |= K_MENU;

    /* OSD On/Off. */
    if ((del_pressed ^ amiga_key_pressed(AMI_DEL)) && (del_pressed ^= 1)) {
        osd_on ^= 1;
        memset(notify.text, 0, sizeof(notify.text));
        if ((running_display_timing == DISP_VGA)
            && (startup_display_spi == DISP_SPI1)) {
            row = 1;
            notify.rows = 3;
            notify.heights = 1u << row; /* Row index 1 -> double height */
        } else {
            row = 0;
            notify.rows = 1;
            notify.heights = 0;
        }
        snprintf((char *)notify.text[row], sizeof(notify.text[row]),
                 "OSD O%s", osd_on ? "n" : "ff");
        notify.cols = (row == 0) ? strlen((char *)notify.text[row])
            : sizeof(notify.text[row]);
        notify.on = TRUE;
        notify_time = time_now();
    }

    /* Check hotkeys. */
    for (i = 0; i < ARRAY_SIZE(config.hotkey); i++) {
        struct config_hotkey *hk = &config.hotkey[i];
        static uint16_t hk_latch;
        bool_t hk_pressed;
        uint32_t s, r;
        char *p;
        /* Unused hotkey? */
        if ((hk->flags ^ HKF_videoswitch) && (hk->pin_mod == 0))
            continue;
        /* Has hotkey press/release state changed? */
        hk_pressed = amiga_key_pressed(AMI_F(i+1));
        if (!((hk_latch>>i & 1) ^ hk_pressed))
            continue;
        /* State has changed: Is the hotkey now pressed? */
        hk_latch ^= 1u << i;
        /* Video input switch hotkey? */
        if (hk_pressed && (hk->flags & HKF_videoswitch)) {
            videoswitch_next();
            memset(notify.text, 0, sizeof(notify.text));
            if ((running_display_timing == DISP_VGA)
                && (startup_display_spi == DISP_SPI1)) {
                row = 1;
                notify.rows = 3;
                notify.heights = 1u << row; /* See OSD On/Off. */
            } else {
                row = 0;
                notify.rows = 1;
                notify.heights = 0;
            }
            strcpy((char *)notify.text[row],
                   vs_state_pretty[videoswitch_state]);
            notify.cols = (row == 0) ? strlen((char *)notify.text[row])
                           : sizeof(notify.text[row]);
            notify.on = TRUE;
            notify_time = time_now();
            continue;
        }
        /* Calculate the GPIO set/reset masks. */
        s = (uint16_t)hk->pin_high << pin_u0;
        r = (uint16_t)(hk->pin_mod & ~hk->pin_high) << pin_u0;
        if (!hk_pressed) {
            if (hk->flags & HKF_momentary) {
                /* Momentary hotkeys have their action reversed on release. */
                gpio_user->bsrr = ((uint32_t)s << 16) | r;
                notify.on = FALSE;
            }
            continue;
        }
        /* Hotkey is now pressed: Perform configured action. */
        gpio_user->bsrr = ((uint32_t)r << 16) | s;
        if (*(p = hk->str)) {
            memset(notify.text, 0, sizeof(notify.text));
            if ((running_display_timing == DISP_VGA)
                && (startup_display_spi == DISP_SPI1)) {

                /* In VGA mode, don't resize the OSD box. */
                char buf[ARRAY_SIZE(notify.text)][ARRAY_SIZE(notify.text[0])];
                int rows;
                rows = 0;
                memset(buf, '\0', sizeof(buf));
                while (*p) {
                    int len = strlen(p);
                    strcpy(buf[rows], p);
                    rows++;
                    p += len + 1;
                }
                notify.rows = rows;
                switch (rows) {
                    case 1:
                        /* One line of text: Double height at second row. */
                        strcpy((char *)notify.text[notify.rows], buf[--rows]);
                        notify.heights = 1u << notify.rows;
                        notify.rows = ARRAY_SIZE(notify.text)-1;
                        break;
                    case 2:
                        /* Two lines of text: Normal height 2nd and 3rd row. */
                        for (rows = 0; rows < notify.rows; rows++)
                            strcpy((char *)notify.text[rows+1], buf[rows]);
                        notify.heights = 0;
                        notify.rows = ARRAY_SIZE(notify.text);
                        break;
                    default:
                        /* Three or four lines of text: Start from first row. */
                        for (rows = 0; rows < notify.rows; rows++)
                            strcpy((char *)notify.text[rows], buf[rows]);
                        notify.heights = 0;
                        notify.rows = ARRAY_SIZE(notify.text);
                        break;
                }
                /* Set notify.cols to maximum to retain the OSD size. */
                notify.cols = ARRAY_SIZE(notify.text[0]);
            } else {
                /* 15 kHz mode or SPI2 output. */
                notify.cols = notify.rows = 0;
                while (*p) {
                    int len = strlen(p);
                    strcpy((char *)notify.text[notify.rows], p);
                    notify.cols = max(notify.cols, len);
                    notify.rows++;
                    p += len + 1;
                }
            }
            notify.cols = max(notify.cols, (int)ARRAY_SIZE(notify.text[0]));
            notify.on = TRUE;
            notify_time = time_now();
        }
    }
}

struct gotek_button {
    bool_t pressed;
    time_t t;
} gl, gr, gs;

static bool_t gotek_active;

static void emulate_gotek_button(
    uint8_t keycode, struct gotek_button *button)
{
    bool_t pressed = (keys & keycode) && gotek_active;
    if (!(pressed ^ button->pressed)) {
        /* No change */
    } else if (pressed) {
        button->t = time_now();
        button->pressed = TRUE;
    } else if (time_diff(button->t, time_now()) > time_ms(200)) {
        button->pressed = FALSE;
    }
}

static void emulate_gotek_buttons(void)
{
    uint8_t b = 0;
    if (config_active)
        gotek_active = FALSE;
    else if (!gotek_active && !keys)
        gotek_active = TRUE; /* only after keys are released */
    emulate_gotek_button(K_LEFT, &gl);
    emulate_gotek_button(K_RIGHT, &gr);
    emulate_gotek_button(K_SELECT, &gs);
    if (gl.pressed) b |= B_LEFT;
    if (gr.pressed) b |= B_RIGHT;
    if (gs.pressed) b |= B_SELECT;
    *(volatile uint8_t *)&i2c_osd_info.buttons = b;
}

/* Called before erasing Flash, to temporarily disable the display. 
 * Flash updates can stall instruction fetch and mess up the OSD. */
void display_off(void)
{
    display_height = 0; /* Display off */
    delay_us(500);      /* Wait for a few hlines (we only really need one) */
}

void setup_spi1(void)
{
    /* Reset SPI Port. */
    rcc->apb2rstr |= RCC_APB2RSTR_SPI1RST;
    rcc->apb2rstr &= ~RCC_APB2RSTR_SPI1RST;
    rcc->apb2enr |= RCC_APB2ENR_SPI1EN;

    /* Configure SPI: 16-bit mode, MSB first, CPOL Low, CPHA Leading Edge. */
    /* SPI1 is on APB2 which runs at 72MHz */
    spi_display_spi1->cr2 = SPI_CR2_TXDMAEN;
    switch (running_display_timing) {
        case DISP_VGA:
            spi_display_spi1->cr1 = (SPI_CR1_MSTR | /* master */
                            SPI_CR1_SSM | SPI_CR1_SSI | /* software NSS */
                            SPI_CR1_SPE | /* enable */
                            SPI_CR1_DFF | /* 16-bit */
                            SPI_CR1_CPHA |
                            SPI_CR1_BR_DIV2); /* 72MHz/2 = 36MHz */
            break;

        case DISP_15KHZ:
        default:
            spi_display_spi1->cr1 = (SPI_CR1_MSTR | /* master */
                            SPI_CR1_SSM | SPI_CR1_SSI | /* software NSS */
                            SPI_CR1_SPE | /* enable */
                            SPI_CR1_DFF | /* 16-bit */
                            SPI_CR1_CPHA |
                            SPI_CR1_BR_DIV8); /* 72MHz/8 = 9MHz */
            break;
    }
}

void setup_spi2(void)
{
    /* Reset SPI Port. */
    rcc->apb1rstr |= RCC_APB1RSTR_SPI2RST;
    rcc->apb1rstr &= ~RCC_APB1RSTR_SPI2RST;
    rcc->apb1enr |= RCC_APB1ENR_SPI2EN;

    /* Configure SPI: 16-bit mode, MSB first, CPOL Low, CPHA Leading Edge. */
    /* SPI2 is on APB1 which runs at 36MHz */
    spi_display_spi2->cr2 = SPI_CR2_TXDMAEN;
    switch (running_display_timing) {
        case DISP_VGA:
            spi_display_spi2->cr1 = (SPI_CR1_MSTR | /* master */
                            SPI_CR1_SSM | SPI_CR1_SSI | /* software NSS */
                            SPI_CR1_SPE | /* enable */
                            SPI_CR1_DFF | /* 16-bit */
                            SPI_CR1_CPHA |
                            SPI_CR1_BR_DIV2); /* 36MHz/2 = 18MHz */
            break;

        case DISP_15KHZ:
        default:
            spi_display_spi2->cr1 = (SPI_CR1_MSTR | /* master */
                            SPI_CR1_SSM | SPI_CR1_SSI | /* software NSS */
                            SPI_CR1_SPE | /* enable */
                            SPI_CR1_DFF | /* 16-bit */
                            SPI_CR1_CPHA |
                            SPI_CR1_BR_DIV4); /* 36MHz/4 = 9MHz */
            break;
    }
}

void setup_spi(uint16_t video_mode)
{
    running_display_timing = video_mode;

    if (startup_display_spi == DISP_SPI1)
        setup_spi1();
    else
        setup_spi2();

    slave_arr_update();
}

static time_t auto_time;
static bool_t do_autosync(void)
{
    unsigned int avg_hz;
    time_t avg_sync_time;
    bool_t valid_sync_data;
    int i;

    if (config.display_timing != DISP_AUTO)
        return FALSE;

    avg_sync_time = 0;
    for (i = 0; i < sync_log_MAX; i++)
        avg_sync_time += sync_log[i];
    avg_sync_time /= sync_log_MAX;

    /* Require all samples to be +/- 10/9,000,000th from average */
    valid_sync_data = (avg_sync_time != 0);
    for (i = 0; i < sync_log_MAX; i++) {
        int diff = sync_log[i] - avg_sync_time;
        if ((diff > 10) || (diff < -10))
            valid_sync_data = FALSE;
    }
    if (!valid_sync_data)
        return FALSE;

    /* 9MHz clock, 15.625kHz => 576 => PAL/NTSC
     * 9MHz clock, 20.000kHz => 450 => my threshold
     * 9MHz clock, 39.130kHz => 230 => VGA */
    avg_hz = 9000000 / avg_sync_time; /* sync time -> frequency in Hz */
    if ((avg_hz < 20000)
        && (running_display_timing != DISP_15KHZ)) {
        /* PAL/NTSC */
        dprintk("Switch to PAL/NTSC: %d Hz < 20kHz\n", avg_hz);
        setup_spi(DISP_15KHZ);
    } else if ((avg_hz >= 20000)
               && (running_display_timing != DISP_VGA)) {
        /* VGA */
        dprintk("Switch to VGA: %d Hz > 20kHz\n", avg_hz);
        setup_spi(DISP_VGA);
    }

    return TRUE;
}

static bool_t do_polarity_autosync(void)
{
    if (config.polarity != SYNC_AUTO)
        return FALSE;

    if (running_polarity == detected_polarity)
        return FALSE;

    dprintk("Polarity to active %s\n",
            detected_polarity ? "HIGH" : "LOW");
    running_polarity = detected_polarity;
    return TRUE;
}

int main(void)
{
    int i;
    time_t frame_time;
    bool_t lost_sync, _keyboard_held, autosync_changed;

    watchdog_init();

    /* Relocate DATA. Initialise BSS. */
    if (_sdat != _ldat)
        memcpy(_sdat, _ldat, _edat-_sdat);
    memset(_sbss, 0, _ebss-_sbss);

    canary_init();

    stm32_init();
    time_init();
    console_init();
    i2c_init();

    /* PC13: Blue Pill Indicator LED (Active Low) */
    gpio_configure_pin(gpioc, 13, GPI_pull_up);

    /* PA0, PA1, PA2: Rotary encoder */
    for (i = 0; i < 3; i++)
        gpio_configure_pin(gpioa, i, GPI_pull_up);

    /* PA8 = CSYNC/HSYNC input */
    gpio_configure_pin(gpio_csync, pin_csync, GPI_pull_up);

    /* PB14 = VSYNC input */
    gpio_configure_pin(gpio_vsync, pin_vsync, GPI_pull_up);

    /* PA3,4,5: Used to be Gotek buttons. Hold LOW to force disconnection. */
    gpio_configure_pin(gpioa, 3, GPO_opendrain(_2MHz, LOW));
    gpio_configure_pin(gpioa, 4, GPO_opendrain(_2MHz, LOW));
    gpio_configure_pin(gpioa, 5, GPO_opendrain(_2MHz, LOW));

    config_init();
    startup_display_spi = config.display_spi;
    startup_dispctl_mode = config.dispctl_mode;
    running_polarity = SYNC_LOW;
    if (config.polarity == SYNC_HIGH)
        running_polarity = SYNC_HIGH;

    /* Set user pin output modes and initial logic levels. */
    user_pin_init();

    /* Display DMA setup: From memory into the Display Timer's CCRx. */
    if (startup_display_spi == DISP_SPI1)
        dma_display_spi1.cpar = (uint32_t)(unsigned long)&spi_display_spi1->dr;
    else
        dma_display_spi2.cpar = (uint32_t)(unsigned long)&spi_display_spi2->dr;

    if (config.display_timing != DISP_AUTO)
        setup_spi(config.display_timing);
    else
        setup_spi(DISP_15KHZ);

    /* PA8 -> EXTI8 ; PB14 -> EXTI14 */
    afio->exticr4 |= 0x0100;
    exti->imr |= m(pin_csync) | m(pin_vsync);

    /* Timer 2 is triggered by Timer 1. On overflow it triggers DMA
     * to start SPI transfer for the current hline. */
    if (startup_display_spi == DISP_SPI1)
        tim2_up_dma.cpar = (uint32_t)(unsigned long)&dma_display_spi1.ccr;
    else
        tim2_up_dma.cpar = (uint32_t)(unsigned long)&dma_display_spi2.ccr;
    tim2_up_dma.cmar = (uint32_t)(unsigned long)&dma_display_ccr;
    tim2_up_dma.cndtr = 1;
    tim2_up_dma.ccr = (DMA_CCR_PL_V_HIGH |
                       DMA_CCR_MSIZE_16BIT |
                       DMA_CCR_PSIZE_32BIT |
                       DMA_CCR_CIRC |
                       DMA_CCR_DIR_M2P |
                       DMA_CCR_EN);
    setup_slave_timer(tim2);

    /* Timer 4 is triggered by Timer 1. On overflow it triggers DMA
     * to enable the OSD box. */
    setup_dispctl_mode();
    tim4_up_dma.cpar = dispctl_reg;
    tim4_up_dma.cmar = (uint32_t)(unsigned long)&dispctl_on;
    tim4_up_dma.cndtr = 1;
    tim4_up_dma.ccr = (DMA_CCR_PL_V_HIGH |
                       DMA_CCR_MSIZE_32BIT |
                       DMA_CCR_PSIZE_32BIT |
                       DMA_CCR_CIRC |
                       DMA_CCR_DIR_M2P |
                       DMA_CCR_EN);
    setup_slave_timer(tim4);

    /* Timer 2 interrupts us horizontally just before the OSD box, so that 
     * we can pause I2C IRQ transfers. */
    tim2->ccmr1 = TIM_CCMR1_CC1S(TIM_CCS_OUTPUT);
    /* AT32F403: Even if output is frozen (OCxM=0), CCxE bit prevents other 
     * AFs from driving the output pin (eg. SPI2_MOSI vs TIM1_CH3). */
    /*tim2->ccer = TIM_CCER_CC1E;*/
    tim2->dier |= TIM_DIER_CC1IE;

    /* CSYNC is on Timer 1 Channel 1. Use it to trigger Timer 2 and 4. */
    tim1->psc = 0;
    tim1->arr = 0xffff;
    tim1->ccmr1 = TIM_CCMR1_CC1S(TIM_CCS_INPUT_TI1);
    tim1->cr2 = TIM_CR2_MMS(2); /* UEV -> TRGO */
    tim1->cr1 = TIM_CR1_ARPE | TIM_CR1_OPM;
    tim1->ccer = TIM_CCER_CC1E;

    /* Timer 1 Channel 3 is used to disable the OSD box. */
    tim1_ch3_dma.cpar = dispctl_reg;
    tim1_ch3_dma.cmar = (uint32_t)(unsigned long)&dispctl_off;
    tim1_ch3_dma.cndtr = 1;
    tim1_ch3_dma.ccr = (DMA_CCR_PL_V_HIGH |
                        DMA_CCR_MSIZE_32BIT |
                        DMA_CCR_PSIZE_32BIT |
                        DMA_CCR_CIRC |
                        DMA_CCR_DIR_M2P |
                        DMA_CCR_TCIE |
                        DMA_CCR_EN);
    tim1->ccmr2 = TIM_CCMR2_CC3S(TIM_CCS_OUTPUT);
    tim1->dier = TIM_DIER_CC3DE;
    tim2->cr2 = TIM_CR2_MMS(2); /* UEV -> TRGO */
    /*tim1->ccer |= TIM_CCER_CC3E;*/ /* See AT32F403 note above */

    /* Timer 1 Channel 4 is used to trigger an IRQ before OSD end. */
    tim1->ccmr2 |= TIM_CCMR2_CC4S(TIM_CCS_OUTPUT);
    tim1->dier |= TIM_DIER_CC4IE;
    /*tim1->ccer |= TIM_CCER_CC4E;*/ /* See AT32F403 note above */

    set_polarity();

    amiga_init();

    rotary = gpioa->idr & 3;
    timer_init(&button_timer, button_timer_fn, NULL);
    timer_set(&button_timer, time_now());

    for (i = 0; i < ARRAY_SIZE(irqs); i++) {
        IRQx_set_prio(irqs[i], SYNC_IRQ_PRI);
        IRQx_set_pending(irqs[i]);
        IRQx_enable(irqs[i]);
    }

    frame_time = auto_time = time_now();
    lost_sync = autosync_changed = FALSE;

    _keyboard_held = keyboard_held;

    /* Initialize slave OSD connected to I2C2. */
    delay_ms(100);   /* Wait for slave to come up. */
    slave_init();

    for (;;) {
        watchdog_kick();

        canary_check();

        /* Wait while displaying OSD box. This avoids modifying config values 
         * etc during the critical display period, which could cause
         * glitches. */
        for (i = 0; i < 5; i++) { /* up to 5ms */
            if (hline < (vstart - 3))
                break;
            delay_ms(1);
        }

        /* Check for losing sync: no valid frame in over 100ms. We repeat the 
         * forced reset every 100ms until sync is re-established. */
        if (time_diff(frame_time, time_now()) > time_ms(100)) {
            if (!lost_sync)
                printk("Sync lost\n");
            lost_sync = TRUE;
            frame_time = time_now();
            IRQ_global_disable();
            tim1->smcr = 0;
            hline = HLINE_EOF;
            IRQ_global_enable();
        }

        /* Periodically apply the measurement results of autosync. */
        if (time_diff(auto_time, time_now()) > time_ms(1000)) {
            auto_time = time_now();
            autosync_changed |= do_autosync();
            autosync_changed |= do_polarity_autosync();
        }

        /* Keyboard hold/release notifier? */
        if (keyboard_held != _keyboard_held) {
            snprintf((char *)notify.text[0], sizeof(notify.text[0]),
                     "Keyboard %s",
                     keyboard_held ? "Held" : "Released");
            notify.cols = strlen((char *)notify.text[0]);
            notify.rows = 1;
            notify.on = TRUE;
            notify_time = time_now();
            _keyboard_held = keyboard_held;
        }

        /* Have we just finished generating a frame? */
        if (frame) {
            uint16_t height;

            if (lost_sync) {
                printk("Sync found\n");
                lost_sync = FALSE;
            }

            frame_time = time_now();
            frame = 0;

            /* Work out what to display next frame. */
            cur_display = config_active ? &config_display
                : osd_on ? &i2c_display : &no_display;
            if (notify.on) {
                if (time_diff(notify_time, time_now()) > time_ms(2000)) {
                    notify.on = FALSE;
                } else {
                    cur_display = &notify;
                }
            }

            slave_display = config_active ? &no_display : cur_display;
            slave_send_display();

            /* Next frame height depends on #rows and height of each row.
             * 10 = 8px font + 2 lines below it.
             * +2 for the 2 lines that render_line() adds at the top */
            height = cur_display->rows*10+2;
            for (i = 0; i < cur_display->rows; i++)
                if (cur_display->heights & (1<<i))
                    height += 8;
            height = min_t(uint16_t, height, MAX_DISPLAY_HEIGHT);

            /* Render to the SPI DMA buffer. */
            for (i = 0; i < height; i++)
                render_line(i, cur_display);
            if (cur_display->on) {
                /* [2 ticks per pixel (at SPI 36MHz rate)]
                 * x [8 pixels per character] x [@cols characters]
                 * + [allowance for OSD box lead-in and lead-out] */

                /* [4 ticks per pixel (at SPI 18MHz rate)]
                 * x [8 pixels per character] x [@cols characters]
                 * + [allowance for OSD box lead-in and lead-out] */

                switch (running_display_timing) {
                case DISP_VGA:
                    if (startup_display_spi == DISP_SPI1)
                        tim1->ccr3 = 2 * 8 * cur_display->cols + 36;
                    else
                        tim1->ccr3 = 4 * 8 * cur_display->cols + 54;
                break;

                /* [8 ticks per pixel (at SPI 9MHz rate)]
                 * x [8 pixels per character] x [@cols characters]
                 * + [allowance for OSD box lead-in and lead-out] */
                case DISP_15KHZ:
                default:
                    tim1->ccr3 = 8 * 8 * cur_display->cols + 80;
                break;
                }

                tim1->ccr4 = tim1->ccr3 - sysclk_us(1);
                barrier(); /* Set post-OSD timeout /then/ enable display */
                if (config.display_2Y)
                    display_height = 2*height;
                else
                    display_height = height;
            } else {
                display_height = 0;
            }

        }

        update_amiga_keys();
        emulate_gotek_buttons();

        /* Clear keyboard-hold/release notifier upon further key presses. */
        if (keys)
            notify.on = FALSE;

        if (buttons) {
            /* Atomically snapshot and clear the button state. */
            uint8_t b;
            uint32_t oldpri;
            oldpri = IRQ_save(TIMER_IRQ_PRI);
            b = buttons;
            buttons = 0;
            IRQ_restore(oldpri);
            /* Fold in keyboard presses. */
            if (config_active) {
                b |= keys & (B_LEFT | B_RIGHT | B_SELECT);
            } else {
                if (keys & K_MENU) b |= B_SELECT;
            }
            /* Fold in button presses remoted via I2C. */
            b |= i2c_buttons_rx;
            /* Pass button presses to config subsystem for processing. */
            config_process(b & ~B_PROCESSED, autosync_changed);
            autosync_changed = FALSE;
        }

        i2c_process();
        videoswitch_update();
    }

    return 0;
}

/*
 * Local variables:
 * mode: C
 * c-file-style: "Linux"
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
